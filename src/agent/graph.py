
from langgraph.graph import START, END, StateGraph
from langgraph.store.base import BaseStore
from agent.configuration import Configuration
from agent.state import InputState, State
from datetime import datetime
from langchain_core.runnables import RunnableConfig
from agent.prompts import DEFAULT_EMAIL_INSTRUCTIONS, MEMORY_UPDATE_INSTRUCTIONS_REINFORCEMENT, SYSTEM_PROMPT
from agent.tools import SEND_EMAIL
from langchain.chat_models import init_chat_model
from agent.schemas import EmailContentSchema
from langgraph.types import interrupt
from typing import Literal
from agent.utils import extract_interrupt_payload, get_memory, update_memory


# Define nodes


def generate_email(state: State, config: RunnableConfig, store: BaseStore):
    """Use llm to generate email content."""
    configuration = Configuration.from_runnable_config(config)

    email_preferences = get_memory(
        store, ("email_preferences", configuration.user_id), DEFAULT_EMAIL_INSTRUCTIONS)

    system_message = {"role": "system", "content": SYSTEM_PROMPT.format(
        prospect_info=state.prospect_info,
        sdr_name=configuration.user_name,
        email_preferences=email_preferences,
        system_time=datetime.now().isoformat()
    )}

    if state.feedback:
        user_message = {
            "role": "user", "content": "The user provided feedback, and their email preferences have been updated accordingly. Generate email subject and body again in light of new preferences."}
    else:
        user_message = {
            "role": "user", "content": "Generate email subject and body."}

    model = init_chat_model(
        configuration.model, temperature=0.0).with_structured_output(EmailContentSchema)
    result = model.invoke([system_message] + state.messages + [user_message])

    ai_message = {
        "role": "ai", "content": f"Subject: {result.subject}\n\n Email body: {result.body}"}

    return {
        "messages": [user_message] + [ai_message],
        "email_content": result,
        "feedback": None
    }


def send_email(state: State, config: RunnableConfig, store: BaseStore):
    """Send or reject email, or provide feedback based on user response."""
    configuration = Configuration.from_runnable_config(config)

    prospect_info = state.prospect_info
    email_content = state.email_content

    raw_response = interrupt(
        {
            "question": "Ready to send?",
            "to": prospect_info.email,
            "subject": email_content.subject,
            "body": email_content.body
        }
    )

    response = extract_interrupt_payload(raw_response)

    # Debug: Print both formats for comparison
    # print(f"Raw response: {raw_response}")
    # print(f"Extracted response: {response}")

    new_state = state

    if response['type'] == 'accept':
        observation = SEND_EMAIL.invoke(
            {
                "to": prospect_info.email,
                "subject": email_content.subject,
                "body": email_content.body
            }
        )

        new_state = {
            "messages": [{"role": "user", "content": observation}]
        }

    elif response['type'] == 'edit':
        new_email_content = response.get("email_content")

        observation = SEND_EMAIL.invoke(
            {
                "to": prospect_info.email,
                "subject": new_email_content.get("subject"),
                "body": new_email_content.get("body")
            }
        )

        # Update memory with edits
        update_memory(store, ("email_preferences", configuration.user_id), [{
            "role": "user",
            "content": f"User edited the email. Here is the initial email generated by the assistant: {email_content}. Here is the edited email: {new_email_content}. Follow all instructions above, and remember: {MEMORY_UPDATE_INSTRUCTIONS_REINFORCEMENT}."
        }], configuration.model)

        new_state = {
            "messages": [{"role": "user", "content": observation}]
        }

    elif response['type'] == 'feedback':
        feedback = response.get("feedback")

        # Update memory with feedback
        update_memory(store, ("email_preferences", configuration.user_id), [{
            "role": "user",
            "content": f"The user provided the below feedback, update the email preferences to capture this. \n\nFeedback: {feedback}"
        }], configuration.model)

        new_state = {
            "email_content": None,
            "feedback": feedback
        }

        # Catch all other responses
    else:
        raise ValueError(f"Invalid response: {response}")

    return new_state

# Define routing after send email


def route_after_send_email(state: State) -> Literal["generate_email", "__end__"]:
    """Route to end or back to llm if feedback provided."""
    if state.feedback:
        return "generate_email"
    else:
        return END


# Define a new graph
builder = StateGraph(State, input=InputState, config_schema=Configuration)

# Define the nodes
builder.add_node("generate_email", generate_email)
builder.add_node("send_email", send_email)

# Set the edges
builder.add_edge(START, "generate_email")
builder.add_edge("generate_email", "send_email")
builder.add_conditional_edges("send_email", route_after_send_email)

# Compile the builder into an executable graph
graph = builder.compile(name="SDR Agent")
